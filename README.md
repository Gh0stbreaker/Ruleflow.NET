<div align="center">
  <img src="Ruleflow.NET/Engine/Images/Ruleflow.NET.png" alt="Ruleflow.NET Logo">
</div>

# Ruleflow.NET

## English

### üåü Overview

Ruleflow.NET is a flexible, high-performance business rules and validation framework for .NET applications. Built with modern C# features and a fluent API design, Ruleflow.NET helps you create, manage, and execute complex business logic and validation rules with minimal code and maximum readability.

> ‚ö†Ô∏è **Note:** Ruleflow.NET is currently under active development. While core functionality is stable, some features may change before the final release.

### ‚ú® Key Features

- **Intuitive Fluent API** - Create complex validation rules with a natural, readable syntax
- **Conditional Logic** - Build sophisticated rule flows with if/then/else and switch expressions
- **Rule Dependencies** - Define rules that depend on the results of other rules
- **Prioritized Execution** - Control the order of rule evaluation with priority settings
- **Comprehensive Results** - Get detailed validation results with configurable severity levels
- **Dependency Awareness** - Built-in dependency graph validation to prevent circular references
- **Clean Separation** - Keep your business logic separate from your application code
- **Intelligent Rule References** - Use lightweight references that resolve rules from a registry when needed
- **Flexible Data Mapping** - Convert dictionaries to objects and back using the built-in DataAutoMapper
- **Batch Validation** - Validate collections of inputs with `BatchValidator`
- **Composite Validators** - Merge results from multiple validators using `CompositeValidator`
- **Shared Validation Context** - Pass data and rule results between rules via `ValidationContext`

### üöÄ Getting Started

#### Installation

```bash
# Coming soon to NuGet!
dotnet add package Ruleflow.NET
```

#### Basic Usage

```csharp
// Create a simple validation rule
var ageRule = RuleflowExtensions.CreateRule<Person>()
    .WithAction(p => {
        if (p.Age < 18)
            throw new ArgumentException("Person must be at least 18 years old");
    })
    .WithMessage("Age validation failed")
    .WithSeverity(ValidationSeverity.Error)
    .Build();

// Create a validator with our rule
var validator = new Validator<Person>(new[] { ageRule });

// Validate a person
var person = new Person { Name = "John", Age = 17 };
var result = validator.CollectValidationResults(person);

// Check the result
if (!result.IsValid)
{
    foreach (var error in result.Errors)
    {
        Console.WriteLine($"{error.Severity}: {error.Message}");
    }
}
```

#### Advanced Validation with Conditional Logic

```csharp
// Create a conditional validation rule
var drivingRule = RuleflowExtensions
    .CreateConditionalRule<Person>(p => p.HasDrivingLicense)
    .Then(builder => builder
        .WithAction(p => {
            if (p.Age < 16)
                throw new ArgumentException("Driving license holders must be at least 16");
        })
        .WithMessage("Invalid driving license")
    )
    .Else(builder => builder
        .WithAction(p => {
            if (p.Age < 13)
                throw new ArgumentException("Non-drivers must be at least 13");
        })
        .WithMessage("Age validation failed")
    )
    .Build();
```

### üîß Advanced Features

#### Dependent Rules

```csharp
// Create rules with dependencies
var primaryRule = RuleflowExtensions.CreateRule<Order>()
    .WithId("PrimaryCheck")
    .WithAction(o => {
        if (o.Amount <= 0)
            throw new ArgumentException("Order amount must be positive");
    })
    .Build();

var dependentRule = RuleflowExtensions.CreateDependentRule<Order>("SecondaryCheck")
    .DependsOn("PrimaryCheck")
    .WithDependencyType(DependencyType.RequiresAllSuccess)
    .WithAction(o => {
        if (o.Items.Count == 0)
            throw new ArgumentException("Order must have at least one item");
    })
    .Build();
```

#### Switch Pattern Rules

```csharp
// Create a switch-based rule
var statusRule = RuleflowExtensions
    .CreateSwitchRule<Order, OrderStatus>(o => o.Status)
    .Case(OrderStatus.Draft, builder => builder
        .WithAction(o => {
            if (o.DraftDate == null)
                throw new ArgumentException("Draft orders must have a draft date");
        })
    )
    .Case(OrderStatus.Submitted, builder => builder
        .WithAction(o => {
            if (o.SubmissionDate == null)
                throw new ArgumentException("Submitted orders must have a submission date");
        })
    )
    .Default(builder => builder
        .WithAction(o => {
            if (o.LastModified == null)
                throw new ArgumentException("All orders must have a last modified date");
        })
    )
    .Build();
```

#### Data Mapping with DataAutoMapper

```csharp
// Define mapping rules
var mapRules = new[]
{
    new DataMappingRule<Person>(p => p.Name, "name", DataType.String, true),
    new DataMappingRule<Person>(p => p.Age, "age", DataType.Int32, true)
};

var mapper = new DataAutoMapper<Person>(mapRules);
var context = new DataContext();

var dictionary = new Dictionary<string, string>
{
    ["name"] = "John",
    ["age"] = "30"
};

Person person = mapper.MapToObject(dictionary, context);
```

#### Working with Rule References

```csharp
var ruleRegistry = new RuleRegistry<Person>();
ruleRegistry.RegisterRule(ageRule);

IRuleReference<Person> reference = ageRule.Reference;

if (reference.TryResolve(ruleRegistry, out var resolved))
{
    // Use resolved rule
}
```

#### Batch Validation

```csharp
var quantityRule = RuleflowExtensions.CreateRule<Item>()
    .WithAction(i =>
    {
        if (i.Quantity <= 0)
            throw new ArgumentException("Quantity must be positive");
    })
    .Build();

var batchValidator = new BatchValidator<Item>(new[] { quantityRule });
var result = batchValidator.CollectValidationResults(items);
```

#### Combining Validators

```csharp
var nameValidator = new Validator<Customer>(new[] { nameRule });
var emailValidator = new Validator<Customer>(new[] { emailRule });

var composite = new CompositeValidator<Customer>(new[] { nameValidator, emailValidator });
var validation = composite.CollectValidationResults(customer);
```

### üèóÔ∏è Architecture

Ruleflow.NET is designed around a set of core interfaces and components:

- **`IValidationRule<T>`** - Base interface for all validation rules
- **`IValidator<T>`** - Interface for validators that can validate objects of type T
- **`IValidationResult`** - Contains the results of a validation operation
- **`ValidationRuleBuilder<T>`** - Fluent API for constructing validation rules
- **`DependencyAwareValidator<T>`** - Validator that supports rule dependencies
- **`ValidationContext`** - Context for validation operations, including results of rule evaluations
- **`BatchValidator<T>`** - Processes lists of inputs and aggregates all errors
- **`CompositeValidator<T>`** - Combines multiple validators into one
- **`DataAutoMapper<T>`** - Maps dictionary data to objects using typed values
- **`RuleReference<T>`** - Lightweight reference that resolves rules from a registry

### üåê Use Cases

- **Form Validation** - Validate user input with complex business rules
- **API Request Validation** - Ensure incoming requests meet your requirements
- **Business Rule Processing** - Execute business logic in a structured, maintainable way
- **Workflow Validation** - Verify that each step in a workflow can proceed
- **Data Integrity Checks** - Ensure your data meets your business constraints

### üìã Roadmap
- [ ] Coming soon!

### üìö Documentation

Comprehensive documentation is in progress and will be available soon.

### üìù Code Comments

The source code now contains detailed XML comments in both Czech and English. These comments explain the purpose of each class and method to help new contributors understand how the framework works.

### ü§ù Contributing

Contributions are welcome! Feel free to submit issues or pull requests to help improve Ruleflow.NET.

### üìÑ License

Ruleflow.NET is licensed under the [Apache License 2.0](LICENSE.txt).

---

Made with ‚ù§Ô∏è

## ƒåesky

### üåü P≈ôehled

Ruleflow.NET je flexibiln√≠ a v√Ωkonn√Ω framework pro obchodn√≠ pravidla a validaci v .NET aplikac√≠ch. D√≠ky modern√≠m funkc√≠m jazyka C# a p≈ôehledn√©mu rozhran√≠ Fluent API v√°m umo≈æn√≠ vytv√°≈ôet, spravovat a vykon√°vat slo≈æitou obchodn√≠ logiku a validaƒçn√≠ pravidla s minimem k√≥du a maxim√°ln√≠ ƒçitelnost√≠.

> ‚ö†Ô∏è **Pozn√°mka:** Ruleflow.NET je moment√°lnƒõ aktivnƒõ vyv√≠jen. Aƒçkoli je z√°kladn√≠ funkƒçnost stabiln√≠, nƒõkter√© vlastnosti se mohou p≈ôed fin√°ln√≠m vyd√°n√≠m zmƒõnit.

### ‚ú® Hlavn√≠ funkce

- **P≈ôehledn√© Fluent API** ‚Äì Tvo≈ôte komplexn√≠ validaƒçn√≠ pravidla p≈ôirozenou a ƒçitelnou syntax√≠
- **Podm√≠nƒõn√° logika** ‚Äì Stavte sofistikovan√© toky pravidel pomoc√≠ konstrukc√≠ if/then/else a switch
- **Z√°vislosti pravidel** ‚Äì Definujte pravidla, kter√° se odv√≠jej√≠ od v√Ωsledk≈Ø jin√Ωch pravidel
- **Prioritn√≠ spou≈°tƒõn√≠** ‚Äì Ovl√°dejte po≈ôad√≠ vyhodnocov√°n√≠ pravidel nastaven√≠m priorit
- **Podrobn√© v√Ωsledky** ‚Äì Z√≠skejte detailn√≠ validaƒçn√≠ v√Ωsledky s konfigurovatelnou z√°va≈ænost√≠
- **Vƒõdom√≠ z√°vislost√≠** ‚Äì Vestavƒõn√° kontrola grafu z√°vislost√≠ br√°n√≠ tvorbƒõ cyklick√Ωch odkaz≈Ø
- **ƒåist√© oddƒõlen√≠** ‚Äì Udr≈æujte obchodn√≠ logiku oddƒõlenou od aplikaƒçn√≠ho k√≥du
- **Inteligentn√≠ odkazy na pravidla** ‚Äì Pr√°ce s pravidly pomoc√≠ slab√Ωch referenc√≠, kter√© lze kdykoli vy≈ôe≈°it z registru
- **Flexibiln√≠ mapov√°n√≠ dat** ‚Äì P≈ôev√°dƒõjte slovn√≠ky na objekty a zpƒõt d√≠ky vestavƒõn√©mu DataAutoMapperu
- **D√°vkov√° validace** ‚Äì Ovƒõ≈ôujte kolekce vstup≈Ø pomoc√≠ `BatchValidator`
- **Kompozitn√≠ valid√°tory** ‚Äì Spojujte v√Ωsledky v√≠cero valid√°tor≈Ø pomoc√≠ `CompositeValidator`
- **Sd√≠len√Ω validaƒçn√≠ kontext** ‚Äì P≈ôed√°vejte data a v√Ωsledky pravidel p≈ôes `ValidationContext`

### üöÄ Zaƒç√≠n√°me

#### Instalace

```bash
# Ji≈æ brzy na NuGet!
dotnet add package Ruleflow.NET
```

#### Z√°kladn√≠ pou≈æit√≠

```csharp
// Vytvo≈ôen√≠ jednoduch√©ho validaƒçn√≠ho pravidla
var ageRule = RuleflowExtensions.CreateRule<Person>()
    .WithAction(p => {
        if (p.Age < 18)
            throw new ArgumentException("Osoba mus√≠ b√Ωt star≈°√≠ ne≈æ 18 let");
    })
    .WithMessage("Chyba p≈ôi ovƒõ≈ôen√≠ vƒõku")
    .WithSeverity(ValidationSeverity.Error)
    .Build();

// Vytvo≈ôen√≠ valid√°toru s na≈°√≠m pravidlem
var validator = new Validator<Person>(new[] { ageRule });

// Validace osoby
var person = new Person { Name = "John", Age = 17 };
var result = validator.CollectValidationResults(person);

// Kontrola v√Ωsledku
if (!result.IsValid)
{
    foreach (var error in result.Errors)
    {
        Console.WriteLine($"{error.Severity}: {error.Message}");
    }
}
```

#### Pokroƒçil√° validace s podm√≠nkami

```csharp
// Vytvo≈ôen√≠ podm√≠nƒõn√©ho validaƒçn√≠ho pravidla
var drivingRule = RuleflowExtensions
    .CreateConditionalRule<Person>(p => p.HasDrivingLicense)
    .Then(builder => builder
        .WithAction(p => {
            if (p.Age < 16)
                throw new ArgumentException("Dr≈æitel√© ≈ôidiƒçsk√©ho pr≈Økazu mus√≠ m√≠t alespo≈à 16 let");
        })
        .WithMessage("Neplatn√Ω ≈ôidiƒçsk√Ω pr≈Økaz")
    )
    .Else(builder => builder
        .WithAction(p => {
            if (p.Age < 13)
                throw new ArgumentException("Nedr≈æitel√© pr≈Økazu mus√≠ m√≠t alespo≈à 13 let");
        })
        .WithMessage("Chyba p≈ôi ovƒõ≈ôen√≠ vƒõku")
    )
    .Build();
```

### üîß Pokroƒçil√© funkce

#### Z√°visl√° pravidla

```csharp
// Vytvo≈ôen√≠ pravidel se z√°vislostmi
var primaryRule = RuleflowExtensions.CreateRule<Order>()
    .WithId("PrimaryCheck")
    .WithAction(o => {
        if (o.Amount <= 0)
            throw new ArgumentException("Hodnota objedn√°vky mus√≠ b√Ωt kladn√°");
    })
    .Build();

var dependentRule = RuleflowExtensions.CreateDependentRule<Order>("SecondaryCheck")
    .DependsOn("PrimaryCheck")
    .WithDependencyType(DependencyType.RequiresAllSuccess)
    .WithAction(o => {
        if (o.Items.Count == 0)
            throw new ArgumentException("Objedn√°vka mus√≠ obsahovat alespo≈à jednu polo≈æku");
    })
    .Build();
```

#### Pravidla typu switch

```csharp
// Vytvo≈ôen√≠ pravidla zalo≈æen√©ho na konstrukci switch
var statusRule = RuleflowExtensions
    .CreateSwitchRule<Order, OrderStatus>(o => o.Status)
    .Case(OrderStatus.Draft, builder => builder
        .WithAction(o => {
            if (o.DraftDate == null)
                throw new ArgumentException("N√°vrhy objedn√°vek mus√≠ m√≠t datum n√°vrhu");
        })
    )
    .Case(OrderStatus.Submitted, builder => builder
        .WithAction(o => {
            if (o.SubmissionDate == null)
                throw new ArgumentException("Odeslan√© objedn√°vky mus√≠ m√≠t datum odesl√°n√≠");
        })
    )
    .Default(builder => builder
        .WithAction(o => {
            if (o.LastModified == null)
                throw new ArgumentException("V≈°echny objedn√°vky mus√≠ m√≠t datum posledn√≠ √∫pravy");
        })
    )
    .Build();
```

#### Mapov√°n√≠ dat pomoc√≠ DataAutoMapperu

```csharp
// Definice mapovac√≠ch pravidel
var mapovaciPravidla = new[]
{
    new DataMappingRule<Person>(p => p.Name, "name", DataType.String, true),
    new DataMappingRule<Person>(p => p.Age, "age", DataType.Int32, true)
};

var mapper = new DataAutoMapper<Person>(mapovaciPravidla);
var context = new DataContext();

var slovnik = new Dictionary<string, string>
{
    ["name"] = "John",
    ["age"] = "30"
};

Person osoba = mapper.MapToObject(slovnik, context);
```

#### Pr√°ce s odkazy na pravidla

```csharp
var registr = new RuleRegistry<Person>();
registr.RegisterRule(ageRule);

IRuleReference<Person> odkaz = ageRule.Reference;

if (odkaz.TryResolve(registr, out var vyresene))
{
    // Pou≈æit√≠ vy≈ôe≈°en√©ho pravidla
}
```

#### D√°vkov√° validace

```csharp
var pravidlo = RuleflowExtensions.CreateRule<Item>()
    .WithAction(i =>
    {
        if (i.Quantity <= 0)
            throw new ArgumentException("Mno≈æstv√≠ mus√≠ b√Ωt kladn√©");
    })
    .Build();

var davkovac = new BatchValidator<Item>(new[] { pravidlo });
var vysledek = davkovac.CollectValidationResults(polozky);
```

#### Kombinace valid√°tor≈Ø

```csharp
var jmenoValidator = new Validator<Customer>(new[] { jmenoPravidlo });
var emailValidator = new Validator<Customer>(new[] { emailPravidlo });

var composite = new CompositeValidator<Customer>(new[] { jmenoValidator, emailValidator });
var validace = composite.CollectValidationResults(zakaznik);
```

### üèóÔ∏è Architektura

Ruleflow.NET je postaven na sadƒõ z√°kladn√≠ch rozhran√≠ a komponent:

- **`IValidationRule<T>`** ‚Äì Z√°kladn√≠ rozhran√≠ pro v≈°echna validaƒçn√≠ pravidla
- **`IValidator<T>`** ‚Äì Rozhran√≠ pro valid√°tory, kter√© mohou ovƒõ≈ôovat objekty typu T
- **`IValidationResult`** ‚Äì Obsahuje v√Ωsledky validaƒçn√≠ operace
- **`ValidationRuleBuilder<T>`** ‚Äì Fluent API pro tvorbu validaƒçn√≠ch pravidel
- **`DependencyAwareValidator<T>`** ‚Äì Valid√°tor podporuj√≠c√≠ z√°vislosti mezi pravidly
- **`ValidationContext`** ‚Äì Kontext validaƒçn√≠ch operac√≠ vƒçetnƒõ v√Ωsledk≈Ø vyhodnocen√≠ pravidel
- **`BatchValidator<T>`** ‚Äì Zpracuje seznamy vstup≈Ø a agreguje chyby
- **`CompositeValidator<T>`** ‚Äì Umo≈æ≈àuje kombinovat v√≠ce valid√°tor≈Ø do jednoho
- **`DataAutoMapper<T>`** ‚Äì Mapuje data mezi slovn√≠kem a objektem pomoc√≠ typovan√Ωch hodnot
- **`RuleReference<T>`** ‚Äì Slab√° reference na pravidlo, kterou lze vy≈ôe≈°it z registru

### üåê P≈ô√≠klady pou≈æit√≠

- **Ovƒõ≈ôov√°n√≠ formul√°≈ô≈Ø** ‚Äì Validace vstup≈Ø od u≈æivatel≈Ø pomoc√≠ komplexn√≠ch pravidel
- **Ovƒõ≈ôov√°n√≠ API po≈æadavk≈Ø** ‚Äì Zaji≈°tƒõn√≠, ≈æe p≈ô√≠choz√≠ po≈æadavky spl≈àuj√≠ va≈°e podm√≠nky
- **Zpracov√°n√≠ obchodn√≠ch pravidel** ‚Äì Spou≈°tƒõn√≠ obchodn√≠ logiky strukturovan√Ωm a udr≈æiteln√Ωm zp≈Øsobem
- **Validace pracovn√≠ch postup≈Ø** ‚Äì Ovƒõ≈ôen√≠, ≈æe ka≈æd√Ω krok ve workflow m≈Ø≈æe pokraƒçovat
- **Kontrola integrity dat** ‚Äì Zajistƒõte, ≈æe va≈°e data spl≈àuj√≠ obchodn√≠ omezen√≠

### üìã Pl√°n v√Ωvoje
- [ ] Ji≈æ brzy!

### üìö Dokumentace

Kompletn√≠ dokumentace je ve v√Ωvoji a bude brzy dostupn√°.

### üìù Koment√°≈ôe v k√≥du

Zdrojov√Ω k√≥d nyn√≠ obsahuje podrobn√© XML koment√°≈ôe v ƒçe≈°tinƒõ i angliƒçtinƒõ. Tyto koment√°≈ôe vysvƒõtluj√≠ √∫ƒçel ka≈æd√© t≈ô√≠dy a metody a pom√°haj√≠ nov√Ωm p≈ôispƒõvatel≈Øm pochopit fungov√°n√≠ r√°mce.

### ü§ù P≈ôisp√≠v√°n√≠

P≈ôispƒõvatel√© jsou v√≠t√°ni! Nev√°hejte zas√≠lat issue nebo pull request pro zlep≈°en√≠ Ruleflow.NET.

### üìÑ Licence

Ruleflow.NET je licencov√°n pod [Apache License 2.0](LICENSE.txt).

---

Vytvo≈ôeno s ‚ù§Ô∏è

